#### 1，Widows下配置gcc环境

配置mingw即可，详情参照mingw配置教程

#### 2，C语言程序开头代码的含义

```txt
程序第一行的#号（Pound Sign，Number Sign或Hash Sign）和include表示包含一个头文件（Header File），后面尖括号（Angel Bracket）中就是文件名（这些头文件通常位于/usr/include目录下）。头文件中声明了我们程序中使用的库函数，根据先声明后使用的原则，要使用printf函数必须包含stdio.h，要使用数学函数必须包含math.h，如果什么库函数都不使用就不必包含任何头文件，例如写一个程序int main(void){int a;a=2;return 0;}，不需要包含头文件就可以编译通过，当然这个程序什么也做不了。

注意：使用math.h中声明的库函数还有一点特殊之处，gcc命令行必须加-lm选项，
因为数学函数位于libm.so库文件中（这些库文件通常位于/lib目录下），-lm选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如printf）位于libc.so库文件中，使用libc.so中的库函数在编译时不需要加-lc选项，当然加了也不算错，因为这个选项是gcc的默认选项。关于头文件和库函数目前理解这么多就可以了
```

#### 3，使用math.h库时注意

后面要加 -lm，否则编译不通过。

```shell
 gcc -Wall RoundNumber.c -o RoundNumber.out -lm
```

#### 4，程序由五种基本指令组成

程序由一系列指令（Instruction）组成，指令是指示计算机做某种运算的命令，通常包括以下几类：

- 输入（Input）

  从键盘、文件或者其它设备获取数据。

- 输出（Output）

  把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。

- 基本运算

  执行最基本的数学运算（加减乘除）和数据存取。

- 测试和分支

  测试某个条件，然后根据不同的测试结果执行不同的后续指令。

- 循环

  重复执行一系列操作。

#### 5，递归和循环

实际所有的循环都可以用递归来代替，递归是计算机的精髓所在，也是编程的精髓所在。

#### 6，数学函数和编程语言函数的区别

数学函数根据已知的数计算出一个结果，没有Side Effect(副作用)。

编程语言函数除了根据输入参数，计算之后得到一个结果——返回值，还有Side Effect，指函数中可能有printf(..)语句打印结果，或则改变了变量的值等。

因此编程分为“函数式编程(Functional programming)”和“命令式编程(Imperative programming)”。
C语言属于命令式编程。Java也是。C++估计也是。

#### 7，左值与右值

int  a = b + 1;

等号左边的 “a” 表示一个存储位置而不是一个值，称作左值(left value)，在程序中如果写作 a + 1 = b 是错误的，而右边的表达式表示的是一个值，需放在右边因此称为右值（right value），目前表达式中有变量可以做左值，还有其它的表达式也可以做左值。

参考《Linux C一站式编程》5. 表达式

#### 8，a +++++ b怎么运算

编译器编译时会逐个字符判断，取最长的合法字符。先判断a+符合语法，然后a++也符合，a+++不符合，最后取a++。同理a++取完之后，再取a++  ++，最后留一个 +b。即a++  ++  +b。

但是当编译器开始语义分析时会报错，因为++要求其变量既可以做左值，a++中a可以做左值，但是a++ ++中“a++”不可以做左值。

#### 9，continue在for和while中使用时的不同

参考：https://blog.csdn.net/o707191418/article/details/81221168

for循环中的i++会执行，而while循环中的i++不会执行。参考个人代码ContinueInForAndWhile.c

#### 10，%lf和%f在printf()和scanf()中的区别

 %f: 表示单浮点精度float
 %lf: 表示双浮点精度double

1,printf()函数中这俩没有区别，因为printf()会自动把单浮点数float向上转型为double
2,scanf()函数中有区别，%f表示收float, %lf表示接收double.

#### 11，Array :数组

##### 1) C编译器不检查越界的原因

以下引自教程

C编译器并不检查count[-1]或是count[100]这样的访问越界错误，编译时能顺利通过，所以属于运行时错误

你可能会想为什么编译器对这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，在第 1 节 “指针的基本概念”会讲到通过指针而不是数组名来访问数组的情况，指针指向数组中的什么位置只有运行时才知道，编译时无法检查是否越界，而运行时每次访问数组元素都检查越界会严重影响性能，所以干脆不检查了；

理由二，[C99 Rationale]指出C语言的设计精神是：相信每个C程序员都是高手，不要阻止程序员去干他们需要干的事，高手们使用count[-1]这种技巧其实并不少见，不应该当作错误。

##### 2) 多维数组

2.1  多维数组的存储方式：

以 int\[3\]\[2\] = { {1,2},{3,4},{5,}} 或者 {1,2,3,4,5};  //最后一个未赋值默认给0

![1700797797808](note-images/1700797797808.png)

概念模型只是为方便理解人们想象出的一种示意图，实际在C语言里这种概念模型称为Row major; 

物理层中在存储器这6个元素是连续存储的，像一维数组一样。

#### 12，C语言的预处理，以及define，Macro宏等的含义

C语言的编译过程实际分为预处理和编译两个阶段。

**Preprocess : 预处理**

首先编译器把代码进行预处理，预处理所做的是把引入的库的代码展开，例如，# include\<stdio.h\>等，对# define定义的变量统一赋值等。预处理之后才进行真正的编译操作。

查看预处理后的数据的命令

```shell
gcc -E Hello.c : 后面什么都不要加，因为还没开始编译
cpp Hello.c : 作用相同
```

下面的代码就是表示指示编译器进行预处理。

**define**

\# define表示指示编译器在预处理阶段把代码中所有N都替换为20，注意这种定义全局变量的方式跟枚举还不一样，枚举enum是在编译阶段给其变量赋值的。

 `define`不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义 

```c
# include <stdio.h>
# include <stdlib.h>
# define N 20
```

**其它:** 

define, include实际并不是C语言的关键字，只是这里写在文件头部，前面加上\# 表示特殊含义。实际代码中也可以使用这两个单词作为标识符。

参照： [Linux C编程一站式学习](./C语言资料/Linux C编程一站式学习.pdf)   ->2. 数组应用实例：统计随机数

#### 13, C99新for语法

这是从C++ 借鉴过来的，gcc命令编译时最后要加上 : " -std=c99"

```c
for(int i = 0; i <= n; i++){...}
```

####  14, 字符串String类型

1，在C语言中没有String这个关键字，字符串是以char[]的形式表示的；

2，例如“Hello, world.\n”在底层是这样的：

![1700125043700](note-images/1700125043700.png)

最后的\0是八进制，十进制也是0，即在ASCII的0~127范围内，用数字"0"字符"Null"，这是一个非显示字符，打印不出来。用这个字符代表一个字符串的结束。
参照[ASCII Table](.\C语言资料\ASCII-Table.jpg)

